@using FinanceManager.Domain.Attachments
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Forms
@using System.Collections.Concurrent
@inject FinanceManager.Shared.IApiClient Api
@inject Microsoft.Extensions.Localization.IStringLocalizer<FinanceManager.Web.Components.Shared.SymbolPicker> Localizer

<div>
    <label>@Localizer["LabelSymbol"]</label><br />
    <div style="display:flex;align-items:center;gap:.6rem;">
        @if (CurrentAttachmentId != null)
        {
            <div style="width:48px;height:48px;border:1px solid var(--border);display:flex;align-items:center;justify-content:center;overflow:hidden;border-radius:6px;">
                <img src="@(_previewUrl ?? $"/api/attachments/{CurrentAttachmentId}/download")" alt="symbol" style="max-width:100%;max-height:100%;display:block;" />
            </div>
            <button class="icon-btn" title="@Localizer["Btn_ClearSymbol"]" @onclick="OnClearClicked"><svg><use href="/icons/sprite.svg#clear" /></svg></button>
        }
        else
        {
            <div style="width:48px;height:48px;border:1px dashed var(--border);display:flex;align-items:center;justify-content:center;border-radius:6px;color:var(--muted);">
                <svg style="width:24px;height:24px;opacity:.6;"><use href="/icons/sprite.svg#image" /></svg>
            </div>
        }

        <!-- Hidden file input; label used as button to open picker -->
        <InputFile id="@_inputId" OnChange="OnInputFileChange" accept="@(_accept)" style="display:none" />
        <label for="@_inputId" class="icon-btn">@Localizer["Btn_UploadSymbol"]</label>
    </div>
    @if (!string.IsNullOrEmpty(_errorKey))
    {
        <div style="color:#e66;margin-top:.5rem;">@Localizer[_errorKey]</div>
    }
</div>

@code {
    private readonly string _inputId = $"symbolpicker_{Guid.NewGuid():N}";
    private string? _accept => AllowedMimeTypes != null && AllowedMimeTypes.Length > 0 ? string.Join(',', AllowedMimeTypes) : null;
    private string? _previewUrl;
    private string? _errorKey;

    private const int TokenValidSeconds = 300; // requested validity
    private const int TokenRefreshBufferSeconds = 10; // refresh before this many seconds remain

    // Simple in-memory cache shared across component instances for token reuse
    private static readonly ConcurrentDictionary<Guid, (string Token, DateTime ExpiresUtc)> _tokenCache = new();

    [Parameter] public AttachmentEntityKind ParentKind { get; set; }
    [Parameter] public Guid? ParentId { get; set; }
    [Parameter] public Guid? CurrentAttachmentId { get; set; }
    // Include common ICO MIME types so .ico files can be uploaded and previewed
    [Parameter] public string[]? AllowedMimeTypes { get; set; } = new[] { "image/png", "image/jpeg", "image/svg+xml", "image/x-icon", "image/vnd.microsoft.icon" };
    [Parameter] public EventCallback<Guid> OnUploaded { get; set; }
    [Parameter] public EventCallback OnClear { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        await EnsurePreviewAsync();
    }

    private async Task EnsurePreviewAsync()
    {
        _previewUrl = null;
        _errorKey = null;
        try
        {
            if (CurrentAttachmentId != null)
            {
                var attachId = CurrentAttachmentId.Value;

                // Check cache first
                if (_tokenCache.TryGetValue(attachId, out var cached))
                {
                    var now = DateTime.UtcNow;
                    if (cached.ExpiresUtc > now.AddSeconds(TokenRefreshBufferSeconds))
                    {
                        _previewUrl = $"/api/attachments/{attachId}/download?token={Uri.EscapeDataString(cached.Token)}";
                        StateHasChanged();
                        return;
                    }
                }

                // Fetch new token and cache it
                var token = await Api.Attachments_CreateDownloadTokenAsync(attachId, TokenValidSeconds);
                if (token != null && !string.IsNullOrWhiteSpace(token.Token))
                {
                    var expires = DateTime.UtcNow.AddSeconds(TokenValidSeconds);
                    _tokenCache[attachId] = (token.Token, expires);
                    _previewUrl = $"/api/attachments/{attachId}/download?token={Uri.EscapeDataString(token.Token)}";
                }
            }
        }
        catch
        {
            _previewUrl = null;
        }
        StateHasChanged();
    }

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        _errorKey = null;
        if (ParentId == null)
        {
            _errorKey = "Error_NoParent";
            return;
        }
        var file = e.File;
        if (file == null) { return; }

        try
        {
            await using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
            var ct = string.IsNullOrWhiteSpace(file.ContentType) ? "application/octet-stream" : file.ContentType;
            var dto = await Api.Attachments_UploadFileAsync((short)ParentKind, ParentId.Value, stream, file.Name, ct, null, (short)FinanceManager.Domain.Attachments.AttachmentRole.Symbol);
            var newId = dto?.Id;
            if (newId.HasValue)
            {
                // Clear any cached token for the new attachment id to force fetching a fresh token
                _tokenCache.TryRemove(newId.Value, out _);
                await EnsurePreviewAsync();
                await OnUploaded.InvokeAsync(newId.Value);
            }
            else
            {
                _errorKey = "Error_ParseResponse";
            }
        }
        catch
        {
            _errorKey = "Error_UploadFailed";
        }
    }

    private async Task OnClearClicked()
    {
        if (OnClear.HasDelegate)
        {
            await OnClear.InvokeAsync();
        }
    }
}
